# Generated by `rjournal_article()` using `knitr::purl()`: do not edit by hand
# Please edit MTBrush_R_Journal.Rmd to modify this file

## ---- echo = FALSE------------------------------------------------------------
library(knitr)
opts_chunk$set(out.width = 400, echo = FALSE, cache = TRUE)
set.seed(100)


## -----------------------------------------------------------------------------
helpers = data.frame(
  "Function" = c("split_dataset(df, group)", "fit_statistics(subsets, lm_func, group)"),
  "Description" = c("This function splits the given data set into many smaller subsets based on the feature of interest. Each subset only contains measurements of a sample and all subsets take same measurements.", "This method maps overall all groups of subsets and returns a set of test statistics associated with each. The testing function can be specified by the user."),
  "Inputs" = c("`df`: A long `data.frame` with sample measurements across all features. `group`: The column name of the feature over which to split the `data.frame` for downstream testing.","`subsets`: List of `data.frame` subsets as output by `split_dataset` `lm_func`: A function that takes one subset of samples and returns a vector of test statistics associated with it. `group`: The name of the column used when initially splitting measurements across features."),
  "Outputs" = c(" A list with one `data.frame` for each feature specified in `group`.","A single `data.frame` with statistics from the collection of tests across features")
)
helpers <- helpers %>%
  mutate_all(linebreak)
library("kableExtra")
kbl(helpers, caption = 'Helper Methods', format = "latex", escape = T) %>%
  kable_styling(full_width = T) 


## ---- echo = TRUE, warning = FALSE, message = FALSE---------------------------
library(MTBrush)
library(tidyverse)

alpha = 2.6
beta1 = 0.3
beta2 = -0.5
beta3 = -1.3

error <- rnorm(20000, 0, 1)

example_data <- expand.grid(
  sample = seq_len(5),
  feature = seq_len(1000),
  X1 = c(FALSE, TRUE),
  X2 = c(FALSE, TRUE)
) %>%
  mutate(
    value = alpha + beta1*X1 + beta2*X2 + beta3*X1*X2 + error,
    condition = case_when( 
      X1 & X2 ~ "X1X2",
      X1 & !X2 ~ "X1",
      !X1 & X2 ~ "X2",
      !X1 & !X2 ~ "Neither"
      )
    )

fit_results <- example_data %>%
  split_dataset(feature) %>%
  fit_statistics(~ lm(value ~ X1 * X2, .), feature)
head(fit_results)


## -----------------------------------------------------------------------------
visulizations = data.frame(
  "Function" = c("draw_stats_histogram( stats_df)", "brush_plots_binary(df, stats_df, group_list, group, value)", "brush_plots_nonbi(df, stats_df, group_list, group, value)"),
  "Description" = c("This function generates histograms of statistics for all terms calculated by `fit_statistics` which also serve as base plots in the Shiny App interface to make interactions on", "This method launchs the Shiny app to show results from previous multiple hypothesis testings and allow users to query for details on conspicuous features. Use this function when the condition/explanatory variables have binary data type.", "This method is similar to `brush_plots_binary`, the only difference is it applys to non-binary explanatory variables."),
  "Inputs" = c("`stats_df`: A `data.frame` contains statistics of tests across features; the output from `fit_statistics(subsets, lm_func, group)` function", "`df`: The same long `data.frame` with sample measurements across all features used in helper methods. `stats_df`: A `data.frame` contains statistics of tests across features. `group_list`: The list of distinct features after splitting the `data.frame`. `group`: The name of the column used when initially splitting measurements across features. `value`: The name of the column used to describe response variable", "Same as above"),
  "Outputs" = c("Histograms of statistics based on results from previous hypothesis testings across features", "A interactive Shiny app interface allow users to explore details of test results", "Same as above")
)
visulizations <- visulizations %>%
  mutate_all(linebreak)
kbl(visulizations, caption = 'Visualization Methods on Test Results', format = "latex", escape = T) %>%
  kable_styling(full_width = T) 


## ---- fig.cap = "The overall MTBrush workflow, including helper functions for deriving multiple hypothesis test statistics and final visualization."----
include_graphics("../../MTBrush/workflow_pic.png")


## ---- eval = FALSE, echo = TRUE-----------------------------------------------
#> brush_plots_binary(example_data, fit_results, seq_len(1000), "feature", "estimate")


## ---- fig.cap = "Descriptions for each section of the initial interface. A: Histograms of test statistics, brush through any one of the histogram to select features;  B: Before brushing, a scatterplot of all features will appear to give an overall distribution of the dataset."----
include_graphics("../../MTBrush/interface1.jpg")


## ---- fig.cap = "Descriptions for each section of the interface after brushing. C: After brushing, test statistics with magnitude within the selected interval will be highlighted (red for selected and orange for reflected values). The selected features will be highlighted across all histograms; D: The scatterplots of top 12 features in the table of selected features will be shown here. By adding or deleting the chosen ID on the left select menu, users can choose to see the scatterplot of features of interest; E: By default, only 12 features will be chosen at first. Users can use the dropdown menu to follow the features of interest; F: The table of selected features in the brushed area. Colors match those in the upper histograms."----
include_graphics("../../MTBrush/interface2.jpg")


## ---- eval = FALSE, echo = TRUE-----------------------------------------------
#> df <- read_csv("../../MTBrush/clean.csv") # Can you include the THOR dataset in the package by default? Or, if it is too large, create a link to directly download this dataset?


## ---- eval = FALSE, echo = TRUE-----------------------------------------------
#> lm_func <- function(x) {
#>   lm(log(value) ~ B * F * K, data = x)
#> }
#> 
#> code <- function(z) { ifelse(str_detect(z, "\\+"), 1, -1) }
#> fits <- df %>%
#>   mutate(across(B:M, code)) %>%
#>   split_dataset(compound) %>%
#>   fit_statistics(lm_func, compound)
#> group_list <- unique(df$compound)


## ---- eval = FALSE, echo = TRUE-----------------------------------------------
#> brush_plots_binary(df, fits, group_list, "compound", "value")


## ---- fig.cap = "The initial interface of the THOR data before interaction"----
include_graphics("../../MTBrush/before.PNG")


## ---- fig.cap = "The interface after brushing through compounds on the left tail of the F histogram"----
include_graphics("../../MTBrush/Thor_example.png")


## ---- eval = FALSE------------------------------------------------------------
#> house_price <- read_csv("../../MTBrush/housing.csv")
#> head(house_price)


## ---- echo = TRUE, eval = FALSE-----------------------------------------------
#> house_cluster <- house_price %>%
#>   select(longitude, latitude) %>%
#>   kmeans(2064)
#> 
#> house_balanced <- cbind(cluster = house_cluster$cluster, house_price) %>%
#>    group_by(cluster) %>%
#>    filter(n() > 10)


## ---- echo = TRUE, eval = FALSE-----------------------------------------------
#> lm_func <- function(x) {
#>   lm(median_house_value ~ population * households * median_income, data = x)
#> }
#> 
#> subsets <- split_dataset(house_balanced, cluster)
#> fits <- fit_statistics(subsets, lm_func, cluster)
#> group_list <- unique(house_balanced$cluster)
#> brush_plots_nonbi(house_balanced, fits, group_list, cluster, median_house_value)


## ---- fig.cap = "The interface after selecting houses with positive households effects in the house price example"----
include_graphics("../../MTBrush/example2.png")

